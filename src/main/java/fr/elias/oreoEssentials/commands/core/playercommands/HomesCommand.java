// File: src/main/java/fr/elias/oreoEssentials/commands/core/playercommands/HomesCommand.java
package fr.elias.oreoEssentials.commands.core.playercommands;

import fr.elias.oreoEssentials.OreoEssentials;
import fr.elias.oreoEssentials.commands.OreoCommand;
import fr.elias.oreoEssentials.services.ConfigService;
import fr.elias.oreoEssentials.services.HomeService;
import fr.elias.oreoEssentials.rabbitmq.channel.PacketChannel;
import fr.elias.oreoEssentials.rabbitmq.packet.PacketManager;
import fr.elias.oreoEssentials.rabbitmq.packet.impl.HomeTeleportRequestPacket;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;

/**
 * /homes           -> list homes (cross-server) + count
 * /homes <name>    -> teleport to that home (cross-server)
 */
public class HomesCommand implements OreoCommand {

    private final HomeService homes;
    private final ConfigService cfg;

    public HomesCommand(HomeService homes) {
        this.homes = homes;
        this.cfg = OreoEssentials.get().getConfigService();
    }

    @Override public String name() { return "homes"; }
    @Override public List<String> aliases() { return List.of("listhomes"); }
    @Override public String permission() { return "oreo.homes"; }
    @Override public String usage() { return "[name]"; }
    @Override public boolean playerOnly() { return true; }

    @Override
    public boolean execute(CommandSender sender, String label, String[] args) {
        if (!(sender instanceof Player p)) return true;

        // With name -> cross-server aware teleport (same path as /home)
        if (args.length >= 1) {
            String raw = args[0];
            String key = normalize(raw);

            String targetServer = homes.homeServer(p.getUniqueId(), key);
            String localServer  = homes.localServer();
            if (targetServer == null) targetServer = localServer;

            // Local teleport
            if (targetServer.equalsIgnoreCase(localServer)) {
                Location loc = getHomeReflect(key, p);
                if (loc == null) {
                    p.sendMessage(ChatColor.RED + "Home not found: " + ChatColor.YELLOW + raw);
                    var list = listNamesCrossServer(p); // cross-server suggestions
                    if (!list.isEmpty()) {
                        p.sendMessage(ChatColor.GRAY + "Available: " + ChatColor.AQUA +
                                String.join(ChatColor.GRAY + ", " + ChatColor.AQUA, list));
                    }
                    return true;
                }
                p.teleport(loc);
                p.sendMessage(ChatColor.GREEN + "Teleported to home " + ChatColor.AQUA + raw);
                return true;
            }

            // Remote -> use RabbitMQ + proxy switch
            var cs = OreoEssentials.get().getCrossServerSettings();
            if (!cs.homes()) {
                p.sendMessage(ChatColor.RED + "Cross-server homes are disabled by server config.");
                p.sendMessage(ChatColor.GRAY + "Use " + ChatColor.AQUA + "/server " + targetServer + ChatColor.GRAY
                        + " then run " + ChatColor.AQUA + "/homes " + key);
                return true;
            }

            final OreoEssentials plugin = OreoEssentials.get();
            final PacketManager pm = plugin.getPacketManager();
            if (pm != null && pm.isInitialized()) {
                final String requestId = UUID.randomUUID().toString();
                HomeTeleportRequestPacket pkt = new HomeTeleportRequestPacket(p.getUniqueId(), key, targetServer, requestId);
                pm.sendPacket(PacketChannel.individual(targetServer), pkt);
            } else {
                p.sendMessage(ChatColor.RED + "Cross-server messaging is disabled. Ask an admin to enable RabbitMQ.");
                p.sendMessage(ChatColor.GRAY + "You can still switch with " + ChatColor.AQUA + "/server " + targetServer
                        + ChatColor.GRAY + " and run " + ChatColor.AQUA + "/homes " + key);
                return true;
            }

            boolean switched = sendPlayerToServer(p, targetServer);
            if (switched) {
                p.sendMessage(ChatColor.YELLOW + "Sending you to " + ChatColor.AQUA + targetServer
                        + ChatColor.YELLOW + "â€¦ you'll be teleported to home " + ChatColor.AQUA + key
                        + ChatColor.YELLOW + " on arrival.");
            } else {
                p.sendMessage(ChatColor.RED + "Failed to switch you to " + targetServer + ".");
            }
            return true;
        }

        // No args -> cross-server list
        List<String> list = listNamesCrossServer(p);
        int used = list.size();
        int max = maxHomes(p);

        if (used == 0) {
            p.sendMessage(ChatColor.YELLOW + "You have no homes. Use " + ChatColor.AQUA + "/sethome <name>");
            return true;
        }

        String cap = (max > 0) ? (used + "/" + max) : (used + "/?");
        p.sendMessage(ChatColor.GOLD + "Homes (" + cap + "): "
                + ChatColor.AQUA + String.join(ChatColor.GRAY + ", " + ChatColor.AQUA, list));
        p.sendMessage(ChatColor.GRAY + "Tip: " + ChatColor.AQUA + "/homes <name>" + ChatColor.GRAY + " to teleport.");
        return true;
    }

    /* ---------------- helpers ---------------- */

    private static String normalize(String s) {
        return s == null ? "" : s.trim().toLowerCase(Locale.ROOT);
    }

    /** Try multiple possible method names to fetch a single home Location from the LOCAL server. */
    private Location getHomeReflect(String key, Player p) {
        UUID id = p.getUniqueId();

        // Location getHome(UUID, String)
        Location loc = invokeLoc(homes, "getHome", new Class[]{UUID.class, String.class}, new Object[]{id, key});
        if (loc != null) return loc;

        // Location home(UUID, String)
        loc = invokeLoc(homes, "home", new Class[]{UUID.class, String.class}, new Object[]{id, key});
        if (loc != null) return loc;

        // Map-based lookup: Map<String, Location> getHomes/homes/listHomes
        Map<String, Location> map = getMapOfHomesReflect(p);
        if (map != null) {
            Location l = map.get(key);
            if (l == null) {
                // case-insensitive match
                for (Map.Entry<String, Location> e : map.entrySet()) {
                    if (normalize(e.getKey()).equals(key)) return e.getValue();
                }
            }
            return l;
        }

        return null;
    }

    /** Cross-server list. Prefer HomeService#homeServers(player) (name->server); fallback to local-only. */
    private List<String> listNamesCrossServer(Player p) {
        try {
            Map<String, String> byServer = homes.homeServers(p.getUniqueId());
            if (byServer != null && !byServer.isEmpty()) {
                // DISPLAY CHOICE:
                // 1) Show "name@server" (uncomment below) if you want clarity on where it lives.
//                return byServer.entrySet().stream()
//                        .filter(e -> e.getKey() != null && !e.getKey().isEmpty())
//                        .map(e -> e.getKey() + "@" + e.getValue())
//                        .sorted(String.CASE_INSENSITIVE_ORDER)
//                        .collect(Collectors.toList());
                // 2) Plain names (default). If duplicates exist across servers, they will appear once each.
                return byServer.keySet().stream()
                        .filter(n -> n != null && !n.isEmpty())
                        .sorted(String.CASE_INSENSITIVE_ORDER)
                        .collect(Collectors.toList());
            }
        } catch (Throwable ignored) {
            // fall through to local-only
        }
        // Fallback: local-only names
        return listNamesReflect(p);
    }

    /** Local-only list via reflection fallbacks. */
    private List<String> listNamesReflect(Player p) {
        Map<String, Location> map = getMapOfHomesReflect(p);
        if (map != null) {
            return map.keySet().stream()
                    .filter(Objects::nonNull)
                    .map(Object::toString)
                    .sorted(String.CASE_INSENSITIVE_ORDER)
                    .collect(Collectors.toList());
        }

        Collection<?> coll = getCollectionOfHomesReflect(p);
        if (coll != null) {
            return coll.stream()
                    .filter(Objects::nonNull)
                    .map(Object::toString)
                    .sorted(String.CASE_INSENSITIVE_ORDER)
                    .collect(Collectors.toList());
        }

        return Collections.emptyList();
    }

    private Map<String, Location> getMapOfHomesReflect(Player p) {
        UUID id = p.getUniqueId();

        Object o = invoke(homes, "getHomes", new Class[]{UUID.class}, new Object[]{id});
        if (o instanceof Map<?, ?> m) return castMapToLoc(m);

        o = invoke(homes, "homes", new Class[]{UUID.class}, new Object[]{id});
        if (o instanceof Map<?, ?> m2) return castMapToLoc(m2);

        o = invoke(homes, "listHomes", new Class[]{UUID.class}, new Object[]{id});
        if (o instanceof Map<?, ?> m3) return castMapToLoc(m3);

        return null;
    }

    private Collection<?> getCollectionOfHomesReflect(Player p) {
        UUID id = p.getUniqueId();

        Object o = invoke(homes, "getHomeNames", new Class[]{UUID.class}, new Object[]{id});
        if (o instanceof Collection<?> c) return c;

        o = invoke(homes, "homes", new Class[]{UUID.class}, new Object[]{id});
        if (o instanceof Collection<?> c2) return c2;

        o = invoke(homes, "listHomes", new Class[]{UUID.class}, new Object[]{id});
        if (o instanceof Collection<?> c3) return c3;

        return null;
    }

    @SuppressWarnings("unchecked")
    private Map<String, Location> castMapToLoc(Map<?, ?> m) {
        Map<String, Location> out = new HashMap<>();
        for (Map.Entry<?, ?> e : m.entrySet()) {
            Object k = e.getKey();
            Object v = e.getValue();
            if (k == null || v == null) continue;
            if (v instanceof Location loc) {
                out.put(k.toString(), loc);
            }
        }
        return out;
    }

    private int maxHomes(Player p) {
        try {
            if (cfg != null) {
                try {
                    Method m = cfg.getClass().getMethod("getMaxHomesFor", Player.class);
                    Object r = m.invoke(cfg, p);
                    if (r instanceof Number n) return n.intValue();
                } catch (NoSuchMethodException ignored) {
                    // fallback to defaultMaxHomes()
                }
                try {
                    Method m2 = cfg.getClass().getMethod("defaultMaxHomes");
                    Object r2 = m2.invoke(cfg);
                    if (r2 instanceof Number n2) return n2.intValue();
                } catch (NoSuchMethodException ignored) {
                    // no method, fall through
                }
            }
        } catch (Throwable ignored) {}
        return -1; // unknown cap -> display "/?"
    }

    /* --------------- reflection helpers --------------- */

    private static Object invoke(Object target, String method, Class<?>[] sig, Object[] args) {
        try {
            Method m = target.getClass().getMethod(method, sig);
            m.setAccessible(true);
            return m.invoke(target, args);
        } catch (Throwable ignored) {
            return null;
        }
    }

    private static Location invokeLoc(Object target, String method, Class<?>[] sig, Object[] args) {
        Object o = invoke(target, method, sig, args);
        return (o instanceof Location) ? (Location) o : null;
    }

    /** Proxy switch (BungeeCord/Velocity plugin message). */
    private boolean sendPlayerToServer(Player p, String serverName) {
        try {
            java.io.ByteArrayOutputStream b = new java.io.ByteArrayOutputStream();
            java.io.DataOutputStream out = new java.io.DataOutputStream(b);
            out.writeUTF("Connect");
            out.writeUTF(serverName);
            p.sendPluginMessage(OreoEssentials.get(), "BungeeCord", b.toByteArray());
            return true;
        } catch (Exception ex) {
            Bukkit.getLogger().warning("[OreoEssentials] Failed to send Connect plugin message: " + ex.getMessage());
            return false;
        }
    }
}
